
## 🎨 フロントエンド要件定義書 Ver. 1.1

### 1\. ページ構成とレイアウト

  * **トップページ (`app/page.tsx`)**
      * 単一のページで、タイムラインUIを提供します。
      * レイアウトはX（旧Twitter）のように、画面中央に配置された単一カラムのフィードとします。
      * PCブラウザを想定し、カラムには最大幅（例: `max-w-2xl`）を設定し、中央揃えにします。
      * ページ上部にはシンプルなヘッダーを配置し、アプリケーションのタイトル（例: 「AI Niche Scroller」）を表示します。

### 2\. コンポーネント詳細定義

#### 2.1. `ArticleCard` (記事カードコンポーネント)

  * **責務:** 1つの記事データを視覚的に表示します。
  * **受け取るProps (例):**
    ```typescript
    interface ArticleCardProps {
      article: {
        title: string;
        article_url: string;
        source_name: string;
        published_at: string; // ISO 8601 形式
        image_url?: string | null;
      };
    }
    ```
  * **表示要件:**
      * **リンク:** カード全体を `<a>` タグで囲み、`href={article_url}` と `target="_blank"` を設定します。
      * **OGP画像:** `image_url` が存在する場合、カードの上部（または横）にアスペクト比を保ったまま表示します（例: `aspect-video`）。`image_url` が `null` または `undefined` の場合は、画像領域自体を表示しません（プレースホルダーは不要）。
      * **タイトル:** `title` を太字で表示します。長すぎる場合は、2行または3行で末尾を省略（`...`）します。（例: `line-clamp-2`）
      * **情報源:** `source_name` を小さめの文字で表示します。（例: "from OpenAI Blog"）
      * **公開日時:** `published_at` の値を「3時間前」「1日前」のような相対表記にフォーマットして表示します。（`date-fns-tz` や `day.js` の利用を推奨）
  * **インタラクション:**
      * マウスホバー時（PC）またはタップ時（SP）に、カードの背景色をわずかに変えるか、少し浮き上がるようなエフェクトを適用します。

#### 2.2. `Timeline` (タイムラインコンポーネント)

  * **責務:** 記事データを取得し、`ArticleCard` のリストとして表示します。無限スクロールのロジックを管理します。
  * **UI/UXの状態管理:**
      * **以下のUI状態を明確に定義し、ユーザーにフィードバックします。**

| 状態 | UI表示 | 実装方法（例） |
| :--- | :--- | :--- |
| **初期ローディング** | ページの初回訪問時。カード型のスケルトンスクリーンを3〜5件表示する。 | Next.js の `loading.tsx` を使用する。 |
| **データ有り (正常)** | `ArticleCard` のリストを時系列（新しい順）で表示する。 | 取得したデータを `map` 処理で `ArticleCard` に渡す。 |
| **データ無し (Empty)** | DBに記事が1件も無い場合。「まだ記事がありません。情報収集バッチが実行されるまでお待ちください。」等のメッセージを表示する。 | |
| **ローディング中 (追加)** | 無限スクロールで次のページを読み込んでいる時。リストの最下部にローディングスピナーを表示する。 | |
| **全件表示完了** | これ以上読み込むデータが無い場合。リストの最下部に「すべての記事を読み込みました」というメッセージを表示する。 | |
| **エラー発生** | データの取得に失敗した場合。「記事の読み込みに失敗しました。時間をおいて再読み込みしてください。」等のメッセージと、再試行ボタンを表示する。 | |

### 3\. データ取得戦略 (パフォーマンス要件)

  * **要件:** タイムラインの初期表示（LCP）が高速（3秒以内）であること。
  * **戦略:** この要件を満たすため、Next.jsの機能を最大限に活用します。

#### 3.1. 初期表示 (1ページ目)

  * **方式:** **ISR (Incremental Static Regeneration)** を採用します。
  * **実装:** `app/page.tsx` を **Dynamic Server Component** とし、`fetch` 関数で `revalidate` オプションを設定します。
    ```typescript
    // app/page.tsx
    export const revalidate = 3600; // 1時間 (3600秒) ごとに再検証

    async function getInitialPosts() {
      // Supabaseから1ページ目(例: 20件)のデータを取得
      const { data } = await supabase.from('articles')...
      return data;
    }

    export default async function HomePage() {
      const initialPosts = await getInitialPosts();
      // ...
    }
    ```
  * **メリット:**
      * ユーザーはVercelのCDNにキャッシュされた静的HTMLを即座に受け取るため、LCPが非常に高速になります。
      * バックエンド（情報収集バッチ）が1時間ごとに記事をDBに追加しても、フロントエンドも1時間ごとに自動で最新情報に更新されます。

#### 3.2. 無限スクロール (2ページ目以降)

  * **方式:** **クライアントサイドフェッチ (CSR)** を採用します。
  * **実装:**
    1.  Next.js の **Route Handler**（例: `app/api/posts/route.ts`）を作成します。このAPIは `page` 番号をクエリパラメータ（`?page=2`）として受け取り、Supabaseから該当ページのデータを返します。
    2.  フロントエンド（`Timeline` コンポーネント）で `Intersection Observer` API を使用し、リストの末尾の要素（ローディングスピナーなど）が画面内に入ったことを検知します。
    3.  検知したら、`fetch`（または `useSWRInfinite` 等のライブラリ）を使い、`app/api/posts?page=...` を叩いて次の記事データを取得し、既存のリストに追加（stateを更新）します。

### 4\. 非機能要件 (再確認)

  * **インフラ:** 上記の (ISR + Vercel) + (Route Handler + Vercel) + (Supabase) + (GitHub Actions) の構成は、個人開発のトラフィック（例：月間数万PV程度）であれば、**すべて無料枠で運用可能**です。
  * **デプロイ:** Vercel と GitHub リポジトリを連携させることで、`main` ブランチへのプッシュをトリガーに自動でビルド＆デプロイが実行され、「容易なデプロイ」要件を満たします。

